<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>ExiFrame - Add EXIF Watermarks & Frames to Your Photos</title>


  <meta name="google-site-verification" content="93o_pvckEcUBBuJzPm4eV4H-1EvSSAjY9I5TnfQk8yI" />
  
  <!-- SEO Meta Tags -->
  <meta name="description" content="Free online tool to add EXIF information (camera, lens, settings) as watermarks to your photos with customizable frames. Support for 50+ fonts and 6 languages." />
  <meta name="keywords" content="EXIF watermark, Free online EXIF viewer, Instantly view camera settings, photo frame, camera metadata, lens information, photography tool, watermark generator, EXIF editor" />
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="author" content="ExiFrame" />
  <meta name="robots" content="index, follow" />
  
  <!-- Open Graph / Facebook -->
  <meta property="og:type" content="website" />
  <meta property="og:url" content="https://yoursite.com/" />
  <meta property="og:title" content="ExiFrame - Add EXIF Watermarks & Frames to Your Photos" />
  <meta property="og:description" content="Free online tool to add EXIF information as watermarks to your photos with customizable frames. Support for 50+ fonts and 6 languages." />
  <meta property="og:image" content="https://yoursite.com/exiframe-logo.png" />
  <meta property="og:image:width" content="1024" />
  <meta property="og:image:height" content="1024" />
  
  <!-- Twitter Card -->
  <meta name="twitter:card" content="summary_large_image" />
  <meta name="twitter:url" content="https://yoursite.com/" />
  <meta name="twitter:title" content="ExiFrame - Add EXIF Watermarks & Frames to Your Photos" />
  <meta name="twitter:description" content="Free online tool to add EXIF information as watermarks to your photos with customizable frames." />
  <meta name="twitter:image" content="https://yoursite.com/exiframe-logo.png" />
  
  <!-- Language Alternates -->
  <link rel="alternate" hreflang="ja" href="https://yoursite.com/?lang=ja" />
  <link rel="alternate" hreflang="en" href="https://yoursite.com/?lang=en" />
  <link rel="alternate" hreflang="zh" href="https://yoursite.com/?lang=zh" />
  <link rel="alternate" hreflang="de" href="https://yoursite.com/?lang=de" />
  <link rel="alternate" hreflang="ko" href="https://yoursite.com/?lang=ko" />
  <link rel="alternate" hreflang="hi" href="https://yoursite.com/?lang=hi" />
  <link rel="alternate" hreflang="x-default" href="https://yoursite.com/" />
  
  <!-- Favicon -->
  <link rel="icon" type="image/png" href="exiframe-logo.png" />
  <link rel="apple-touch-icon" href="exiframe-logo.png" />

  <!-- =========================
       ■ スタイル（最小限のUI）
       ========================= -->
  <style>
    :root{--bg:#f8fafc;--ink:#0f172a;--muted:#475569;--card:#ffffff;--line:#e2e8f0;--accent:#0f172a}
    *{box-sizing:border-box}body{margin:0;background:var(--bg);color:var(--ink);font:16px/1.6 system-ui,-apple-system,"Segoe UI",Roboto,Arial,Meiryo,"Hiragino Kaku Gothic ProN",sans-serif}
    header{position:sticky;top:0;background:rgba(255,255,255,.8);backdrop-filter:saturate(180%) blur(8px);border-bottom:1px solid var(--line);z-index:10}
    .wrap{max-width:1120px;margin:0 auto;padding:16px}
    h1{margin:0;font-size:18px}
    main{display:grid;grid-template-columns:1fr;gap:20px;padding:16px}
    @media(min-width:960px){main{grid-template-columns:520px 1fr}}
    .card{background:var(--card);border:1px solid var(--line);border-radius:16px;padding:16px;box-shadow:0 1px 0 rgba(15,23,42,.02)}
    label{font-size:14px}
    input[type="text"],input[type="password"],textarea,select{width:100%;padding:8px 10px;border:1px solid var(--line);border-radius:10px}
    textarea{min-height:96px}
    .row{display:grid;grid-template-columns:1fr 1fr;gap:12px}
    .btn{display:inline-flex;align-items:center;gap:8px;padding:10px 14px;border-radius:12px;border:1px solid var(--line);background:#fff;color:var(--ink);cursor:pointer}
    .btn.primary{border-color:transparent;background:var(--accent);color:#fff}
    .muted{color:var(--muted);font-size:12px}
    .preview{position:sticky;top:88px;height:calc(100dvh - 120px);display:flex;align-items:center;justify-content:center;background:#000;border:1px solid var(--line);border-radius:16px;overflow:hidden}
  canvas{max-width:100%;max-height:100%;object-fit:contain;cursor:grab;transition:transform 0.1s ease-out;transform-origin:center center}
  canvas:active{cursor:grabbing}
    .pill{display:inline-block;padding:2px 8px;font-size:12px;border-radius:999px;background:#000;color:#fff}
    .off{opacity:.45;pointer-events:none}
    .inline-controls{display:flex;gap:12px;flex-wrap:wrap}
  </style>

  <!-- Webフォント（遅延読み込み）-->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link
    href="https://fonts.googleapis.com/css2?family=Noto+Sans+JP:wght@400;700&family=Shippori+Mincho:wght@600&display=swap"
    rel="stylesheet"
    media="print"
    onload="this.media='all'">
  <noscript>
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+JP:wght@400;700&family=Shippori+Mincho:wght@600&display=swap" rel="stylesheet">
  </noscript>

  <!-- EXIF読み取りライブラリ（遅延読み込み）-->
  <script src="https://cdn.jsdelivr.net/npm/exifr@7/dist/full.umd.js" defer></script>
</head>
<body>
  <!-- =========================
       ■ ヘッダ
       ========================= -->
  <header>
    <div class="wrap" style="display:flex;align-items:center;justify-content:space-between;gap:12px">
      <div style="display:flex;align-items:center;gap:10px">
        <img src="exiframe-logo.png" alt="ExiFrame Logo" style="width:112px;height:112px;border-radius:16px" />
        <h1>ExiFrame</h1>
      </div>
      <div style="display:flex;gap:8px">
        <select id="langSelect" class="btn" style="padding:8px 12px;cursor:pointer">
          <option value="ja">日本語</option>
          <option value="en">English</option>
          <option value="zh">中文</option>
          <option value="de">Deutsch</option>
          <option value="ko">한국어</option>
          <option value="hi">हिन्दी</option>
        </select>
      </div>
    </div>
  </header>

  <main class="wrap">
    <section class="left">
      <!-- 概要説明 -->
      <div class="card">
        <h2>概要</h2>
        <p>このツールは、写真にEXIF情報（カメラ、レンズ、撮影設定など）を透かしとして追加し、フレームを付けて書き出すことができます。</p>
        <p class="muted" style="margin-top:8px">
          ・EXIF情報を自動抽出して透かしテキストを生成<br>
          ・テンプレート選択で表示スタイルを変更<br>
          ・フレームの色や幅を自由に調整<br>
          ・50種類以上のフォントから選択可能
        </p>
      </div>

      <!-- 1. 画像選択 -->
      <div class="card">
        <h2>1. 画像を選ぶ</h2>
        <input type="file" id="file" accept="image/*" style="display:none" />
        <button class="btn" id="fileSelectBtn" onclick="document.getElementById('file').click()">ファイルを選択</button>
        <span id="fileName" class="muted" style="margin-left:8px"></span>
        <p class="muted" style="margin-top:8px">EXIF入りのJPEG推奨。RAWはブラウザでは不可。</p>
      </div>

      <!-- 2. テンプレート選択 -->
      <div class="card">
        <h2>2. テンプレート選択</h2>
        <label>レイアウト
          <select id="template">
            <option value="default">デフォルト（詳細表示）</option>
            <option value="simple">シンプル（中央レイアウト）</option>
          </select>
        </label>
        <p class="muted">※ デフォルト：左下に詳細情報を表示　※ シンプル：中央下部に大きくカメラ・レンズ名を表示</p>
      </div>

      <!-- 3. 透かし設定（EXIFから自動入力） -->
      <div class="card">
        <h2>3. 透かし設定</h2>
        <label>テキスト（自動生成を上書き可。改行対応）</label>
        <textarea id="wmText"></textarea>

        <div class="row" style="margin-top:10px">
          <label>位置
            <select id="pos">
              <option value="bl" selected>左下</option>
              <option value="br">右下</option>
              <option value="tl">左上</option>
              <option value="tr">右上</option>
              <option value="bc">中央下</option>
              <option value="tc">中央上</option>
              <option value="cl">中央左</option>
              <option value="cr">中央右</option>
            </select>
          </label>
          <label>テキスト揃え
            <select id="textAlign">
              <option value="left">左揃え</option>
              <option value="center">中央揃え</option>
              <option value="right">右揃え</option>
            </select>
          </label>
        </div>
        <div class="row" style="margin-top:10px">
          <label>スケール
            <input type="range" id="scale" min="0.6" max="2" step="0.05" value="1" />
          </label>
        </div>

        <!-- フォント選択 -->
        <div class="row" style="margin-top:10px">
          <label>フォント
            <select id="fontFamily">
              <option value="system-ui,-apple-system,Segoe UI,Roboto,Arial,Meiryo,'Hiragino Kaku Gothic ProN',sans-serif">標準（サンセリフ）</option>
              <option value="'Noto Sans JP', system-ui,-apple-system,Segoe UI,Roboto,Arial,Meiryo,'Hiragino Kaku Gothic ProN',sans-serif">Noto Sans JP</option>
              <option value="'Shippori Mincho', 'Hiragino Mincho ProN','Hiragino Mincho Pro','Yu Mincho','YuMincho',serif">しっぽり明朝</option>
              <option value="'Yu Gothic',YuGothic,Meiryo,system-ui,-apple-system,sans-serif">游ゴシック</option>
              <option value="'Hiragino Kaku Gothic ProN',Meiryo,system-ui,-apple-system,sans-serif">ヒラギノ角ゴ</option>
              <option value="Arial,Helvetica,sans-serif">Arial</option>
              <option value="Helvetica,Arial,sans-serif">Helvetica</option>
              <option value="'Helvetica Neue',Helvetica,Arial,sans-serif">Helvetica Neue</option>
              <option value="'Times New Roman',Times,serif">Times New Roman</option>
              <option value="Georgia,serif">Georgia</option>
              <option value="Garamond,serif">Garamond</option>
              <option value="'Palatino Linotype',Palatino,serif">Palatino</option>
              <option value="'Book Antiqua',Palatino,serif">Book Antiqua</option>
              <option value="'Courier New',Courier,monospace">Courier New</option>
              <option value="Monaco,Courier,monospace">Monaco</option>
              <option value="Verdana,Geneva,sans-serif">Verdana</option>
              <option value="Tahoma,Geneva,sans-serif">Tahoma</option>
              <option value="'Trebuchet MS',sans-serif">Trebuchet MS</option>
              <option value="'Lucida Sans',sans-serif">Lucida Sans</option>
              <option value="Impact,Charcoal,sans-serif">Impact</option>
              <option value="'Comic Sans MS',cursive">Comic Sans MS</option>
              <option value="'Century Gothic',sans-serif">Century Gothic</option>
              <option value="'Franklin Gothic Medium',sans-serif">Franklin Gothic</option>
              <option value="Optima,sans-serif">Optima</option>
              <option value="'Gill Sans',sans-serif">Gill Sans</option>
              <option value="Futura,sans-serif">Futura</option>
              <option value="'Avenir Next',Avenir,sans-serif">Avenir</option>
              <option value="Rockwell,serif">Rockwell</option>
              <option value="Baskerville,serif">Baskerville</option>
              <option value="'Bodoni MT',serif">Bodoni</option>
              <option value="Didot,serif">Didot</option>
              <option value="'Hoefler Text',serif">Hoefler Text</option>
              <option value="Cambria,serif">Cambria</option>
              <option value="Constantia,serif">Constantia</option>
              <option value="'Big Caslon',serif">Big Caslon</option>
              <option value="'American Typewriter',serif">American Typewriter</option>
              <option value="Copperplate,sans-serif">Copperplate</option>
              <option value="'Lucida Grande',sans-serif">Lucida Grande</option>
              <option value="Calibri,sans-serif">Calibri</option>
              <option value="Candara,sans-serif">Candara</option>
              <option value="Corbel,sans-serif">Corbel</option>
              <option value="'Segoe UI',Tahoma,sans-serif">Segoe UI</option>
              <option value="'Open Sans',sans-serif">Open Sans</option>
              <option value="Lato,sans-serif">Lato</option>
              <option value="Montserrat,sans-serif">Montserrat</option>
              <option value="Roboto,sans-serif">Roboto</option>
              <option value="'Roboto Condensed',sans-serif">Roboto Condensed</option>
              <option value="'Source Sans Pro',sans-serif">Source Sans Pro</option>
              <option value="Raleway,sans-serif">Raleway</option>
              <option value="'PT Sans',sans-serif">PT Sans</option>
            </select>
          </label>
          <label>カスタム指定（任意・先頭に適用）
            <input type="text" id="fontCustom" placeholder="例: 'EB Garamond', serif">
          </label>
        </div>

        <!-- 背景ON/OFF -->
        <div class="inline-controls" style="margin-top:10px">
          <label><input type="checkbox" id="wmBg" checked> 透かし背景（枠）を表示</label>
        </div>

        <!-- 配置基準＆文字方向 -->
        <div class="row" style="margin-top:10px">
          <label>配置基準
            <select id="wmPlacement">
              <option value="photo">写真内側</option>
              <option value="canvas">フレーム外側含む全体</option>
            </select>
          </label>
          <label>文字方向
            <select id="wmOrientation">
              <option value="horizontal">横書き</option>
              <option value="rotate-ccw">90°回転（反時計回り）</option>
              <option value="rotate-cw">90°回転（時計回り）</option>
            </select>
          </label>
        </div>
      </div>

      <!-- 4. フレーム設定 -->
      <div class="card">
        <h2>4. フレーム設定</h2>
        
        <!-- フレームON/OFF -->
        <label style="display:flex;align-items:center;gap:8px"><input type="checkbox" id="showFrame"> フレームを付ける</label>

        <!-- フレーム色選択 -->
        <label style="margin-top:8px">フレーム色
          <select id="frameColor">
            <option value="white">白</option>
            <option value="black">黒</option>
          </select>
        </label>
        <p class="muted" style="margin-top:4px;font-size:11px">※ 黒を選択すると、透かし文字が白に変更されます</p>

        <!-- 四辺個別の幅設定 -->
        <div style="margin-top:12px">
          <label>上のフレーム幅
            <div style="display:flex;gap:8px;align-items:center;margin-top:4px">
              <input type="range" id="frameTopW" min="0" max="700" step="2" value="40" style="flex:1" />
              <input type="number" id="frameTopWInput" min="0" max="700" step="1" value="40" style="width:70px;padding:4px 6px" />
              <span class="muted px-label">px</span>
            </div>
          </label>
        </div>
        <div style="margin-top:8px">
          <label>下のフレーム幅
            <div style="display:flex;gap:8px;align-items:center;margin-top:4px">
              <input type="range" id="frameBottomW" min="0" max="700" step="2" value="40" style="flex:1" />
              <input type="number" id="frameBottomWInput" min="0" max="700" step="1" value="40" style="width:70px;padding:4px 6px" />
              <span class="muted px-label">px</span>
            </div>
          </label>
        </div>
        <div style="margin-top:8px">
          <label>左のフレーム幅
            <div style="display:flex;gap:8px;align-items:center;margin-top:4px">
              <input type="range" id="frameLeftW" min="0" max="700" step="2" value="40" style="flex:1" />
              <input type="number" id="frameLeftWInput" min="0" max="700" step="1" value="40" style="width:70px;padding:4px 6px" />
              <span class="muted px-label">px</span>
            </div>
          </label>
        </div>
        <div style="margin-top:8px">
          <label>右のフレーム幅
            <div style="display:flex;gap:8px;align-items:center;margin-top:4px">
              <input type="range" id="frameRightW" min="0" max="700" step="2" value="40" style="flex:1" />
              <input type="number" id="frameRightWInput" min="0" max="700" step="1" value="40" style="width:70px;padding:4px 6px" />
              <span class="muted px-label">px</span>
            </div>
          </label>
        </div>
      </div>

      <!-- 5. 出力 -->
      <div class="card">
        <h2>5. 出力</h2>
        <button class="btn primary" id="save" disabled>画像を書き出す（JPG）</button>
        <div style="margin-top:10px">
          <label>JPEG 品質（50%〜100%）
            <input type="range" id="quality" min="0.5" max="1" step="0.01" value="0.92" />
            <span class="muted">現在: <b><span id="qval">0.92</span></b></span>
          </label>
        </div>
        
        <!-- 品質ガイド表 -->
        <div style="margin-top:16px;font-size:13px">
          <p class="muted" style="margin-bottom:8px" id="qualityGuideTitle"><strong>品質による違い</strong></p>
          <table style="width:100%;border-collapse:collapse;font-size:12px">
            <thead>
              <tr style="border-bottom:1px solid var(--line)">
                <th style="padding:6px 4px;text-align:left" id="qualityTableHeader1">品質</th>
                <th style="padding:6px 4px;text-align:left" id="qualityTableHeader2">ファイルサイズ</th>
                <th style="padding:6px 4px;text-align:left" id="qualityTableHeader3">用途</th>
              </tr>
            </thead>
            <tbody>
              <tr style="border-bottom:1px solid var(--line)">
                <td style="padding:6px 4px">50-70%</td>
                <td style="padding:6px 4px" id="qualityRow1Size">小</td>
                <td style="padding:6px 4px" id="qualityRow1Use">Web軽量化、サムネイル</td>
              </tr>
              <tr style="border-bottom:1px solid var(--line)">
                <td style="padding:6px 4px">75-85%</td>
                <td style="padding:6px 4px" id="qualityRow2Size">中</td>
                <td style="padding:6px 4px" id="qualityRow2Use">SNS投稿、Web表示</td>
              </tr>
              <tr style="border-bottom:1px solid var(--line)">
                <td style="padding:6px 4px">90-95%</td>
                <td style="padding:6px 4px" id="qualityRow3Size">大</td>
                <td style="padding:6px 4px" id="qualityRow3Use">高品質保存、印刷</td>
              </tr>
              <tr>
                <td style="padding:6px 4px">95-100%</td>
                <td style="padding:6px 4px" id="qualityRow4Size">非常に大</td>
                <td style="padding:6px 4px" id="qualityRow4Use">アーカイブ、プロ用</td>
              </tr>
            </tbody>
          </table>
          <p class="muted" style="margin-top:8px;font-size:11px" id="qualityNote">※ デフォルト92%は高品質とファイルサイズのバランスが良い設定です</p>
        </div>
      </div>
    </section>

    <!-- プレビュー（キャンバス） -->
    <section class="preview">
      <canvas id="cv" width="1920" height="1080"></canvas>
      <img id="img" alt="preview" style="display:none" />
    </section>
  </main>

  <!-- =========================
       ■ スクリプト
       ========================= -->
  <script>
    // ====== 多言語対応翻訳データ ======
    const translations = {
      ja: {
        overview: "概要",
        overviewText: "このツールは、写真にEXIF情報（カメラ、レンズ、撮影設定など）を透かしとして追加し、フレームを付けて書き出すことができます。",
        overviewFeatures: "・EXIF情報を自動抽出して透かしテキストを生成<br>・テンプレート選択で表示スタイルを変更<br>・フレームの色や幅を自由に調整<br>・50種類以上のフォントから選択可能",
        selectImage: "1. 画像を選ぶ",
        selectFile: "ファイルを選択",
        exifNote: "EXIF入りのJPEG推奨。RAWはブラウザでは不可。",
        selectTemplate: "2. テンプレート選択",
        layout: "レイアウト",
        defaultTemplate: "デフォルト（詳細表示）",
        simpleTemplate: "シンプル（中央レイアウト）",
        templateNote: "※ デフォルト：左下に詳細情報を表示　※ シンプル：中央下部に大きくカメラ・レンズ名を表示",
        watermarkSettings: "3. 透かし設定",
        textLabel: "テキスト（自動生成を上書き可。改行対応）",
        position: "位置",
        posBottomLeft: "左下",
        posBottomRight: "右下",
        posTopLeft: "左上",
        posTopRight: "右上",
        posBottomCenter: "中央下",
        posTopCenter: "中央上",
        posCenterLeft: "中央左",
        posCenterRight: "中央右",
        textAlign: "テキスト揃え",
        alignLeft: "左揃え",
        alignCenter: "中央揃え",
        alignRight: "右揃え",
        scale: "スケール",
        fontLabel: "フォント",
        customFont: "カスタム指定（任意・先頭に適用）",
        customFontPlaceholder: "例: 'EB Garamond', serif",
        showBackground: "透かし背景（枠）を表示",
        placementBase: "配置基準",
        placementPhoto: "写真内側",
        placementCanvas: "フレーム外側含む全体",
        textDirection: "文字方向",
        horizontal: "横書き",
        rotateCCW: "90°回転（反時計回り）",
        rotateCW: "90°回転（時計回り）",
        frameSettings: "4. フレーム設定",
        addFrame: "フレームを付ける",
        frameColor: "フレーム色",
        white: "白",
        black: "黒",
        frameColorNote: "※ 黒を選択すると、透かし文字が白に変更されます",
        frameTop: "上のフレーム幅",
        frameBottom: "下のフレーム幅",
        frameLeft: "左のフレーム幅",
        frameRight: "右のフレーム幅",
        output: "5. 出力",
        exportImage: "画像を書き出す（JPG）",
        jpegQuality: "JPEG 品質（50%〜100%）",
        currentQuality: "現在: ",
        qualityGuideTitle: "品質による違い",
        qualityTableHeader1: "品質",
        qualityTableHeader2: "ファイルサイズ",
        qualityTableHeader3: "用途",
        qualityRow1Size: "小",
        qualityRow1Use: "Web軽量化、サムネイル",
        qualityRow2Size: "中",
        qualityRow2Use: "SNS投稿、Web表示",
        qualityRow3Size: "大",
        qualityRow3Use: "高品質保存、印刷",
        qualityRow4Size: "非常に大",
        qualityRow4Use: "アーカイブ、プロ用",
        qualityNote: "※ デフォルト92%は高品質とファイルサイズのバランスが良い設定です"
      },
      en: {
        overview: "Overview",
        overviewText: "This tool allows you to add EXIF information (camera, lens, shooting settings, etc.) as a watermark to your photos and export them with frames.",
        overviewFeatures: "・Automatically extract EXIF info to generate watermark text<br>・Change display style with template selection<br>・Freely adjust frame color and width<br>・Choose from over 50 fonts",
        selectImage: "1. Select Image",
        selectFile: "Select File",
        exifNote: "JPEG with EXIF recommended. RAW not supported in browser.",
        selectTemplate: "2. Template Selection",
        layout: "Layout",
        defaultTemplate: "Default (Detailed)",
        simpleTemplate: "Simple (Center Layout)",
        templateNote: "※ Default: Display detailed info at bottom left　※ Simple: Display camera/lens name large at bottom center",
        watermarkSettings: "3. Watermark Settings",
        textLabel: "Text (Can override auto-generated. Line breaks supported)",
        position: "Position",
        posBottomLeft: "Bottom Left",
        posBottomRight: "Bottom Right",
        posTopLeft: "Top Left",
        posTopRight: "Top Right",
        posBottomCenter: "Bottom Center",
        posTopCenter: "Top Center",
        posCenterLeft: "Center Left",
        posCenterRight: "Center Right",
        textAlign: "Text Alignment",
        alignLeft: "Left",
        alignCenter: "Center",
        alignRight: "Right",
        scale: "Scale",
        fontLabel: "Font",
        customFont: "Custom Font (Optional)",
        customFontPlaceholder: "e.g., 'EB Garamond', serif",
        showBackground: "Show watermark background",
        placementBase: "Placement Base",
        placementPhoto: "Inside Photo",
        placementCanvas: "Entire Canvas (including frame)",
        textDirection: "Text Direction",
        horizontal: "Horizontal",
        rotateCCW: "Rotate 90° (CCW)",
        rotateCW: "Rotate 90° (CW)",
        frameSettings: "4. Frame Settings",
        addFrame: "Add Frame",
        frameColor: "Frame Color",
        white: "White",
        black: "Black",
        frameColorNote: "※ Selecting black will change watermark text to white",
        frameTop: "Top Frame Width",
        frameBottom: "Bottom Frame Width",
        frameLeft: "Left Frame Width",
        frameRight: "Right Frame Width",
        output: "5. Output",
        exportImage: "Export Image (JPG)",
        jpegQuality: "JPEG Quality (50%～100%)",
        currentQuality: "Current: ",
        qualityGuideTitle: "Quality Differences",
        qualityTableHeader1: "Quality",
        qualityTableHeader2: "File Size",
        qualityTableHeader3: "Use Case",
        qualityRow1Size: "Small",
        qualityRow1Use: "Web optimization, thumbnails",
        qualityRow2Size: "Medium",
        qualityRow2Use: "SNS posts, web display",
        qualityRow3Size: "Large",
        qualityRow3Use: "High quality storage, printing",
        qualityRow4Size: "Very large",
        qualityRow4Use: "Archive, professional use",
        qualityNote: "※ Default 92% offers a good balance between quality and file size"
      },
      zh: {
        overview: "概述",
        overviewText: "此工具可将EXIF信息（相机、镜头、拍摄设置等）作为水印添加到照片中，并添加边框后导出。",
        overviewFeatures: "・自动提取EXIF信息生成水印文本<br>・通过模板选择更改显示样式<br>・自由调整边框颜色和宽度<br>・可从50多种字体中选择",
        selectImage: "1. 选择图片",
        selectFile: "选择文件",
        exifNote: "推荐带EXIF的JPEG。浏览器不支持RAW。",
        selectTemplate: "2. 模板选择",
        layout: "布局",
        defaultTemplate: "默认（详细显示）",
        simpleTemplate: "简单（居中布局）",
        templateNote: "※ 默认：在左下角显示详细信息　※ 简单：在底部中央大字显示相机/镜头名称",
        watermarkSettings: "3. 水印设置",
        textLabel: "文本（可覆盖自动生成。支持换行）",
        position: "位置",
        posBottomLeft: "左下",
        posBottomRight: "右下",
        posTopLeft: "左上",
        posTopRight: "右上",
        posBottomCenter: "中央下",
        posTopCenter: "中央上",
        posCenterLeft: "中央左",
        posCenterRight: "中央右",
        textAlign: "文本对齐",
        alignLeft: "左对齐",
        alignCenter: "居中对齐",
        alignRight: "右对齐",
        scale: "缩放",
        fontLabel: "字体",
        customFont: "自定义字体（可选）",
        customFontPlaceholder: "例如: 'EB Garamond', serif",
        showBackground: "显示水印背景（框）",
        placementBase: "放置基准",
        placementPhoto: "照片内部",
        placementCanvas: "整个画布（包含边框）",
        textDirection: "文字方向",
        horizontal: "横向",
        rotateCCW: "旋转90°（逆时针）",
        rotateCW: "旋转90°（顺时针）",
        frameSettings: "4. 边框设置",
        addFrame: "添加边框",
        frameColor: "边框颜色",
        white: "白色",
        black: "黑色",
        frameColorNote: "※ 选择黑色时，水印文字将变为白色",
        frameTop: "上边框宽度",
        frameBottom: "下边框宽度",
        frameLeft: "左边框宽度",
        frameRight: "右边框宽度",
        output: "5. 输出",
        exportImage: "导出图片（JPG）",
        jpegQuality: "JPEG 质量（50%～100%）",
        currentQuality: "当前: ",
        qualityGuideTitle: "品质差异",
        qualityTableHeader1: "品质",
        qualityTableHeader2: "文件大小",
        qualityTableHeader3: "用途",
        qualityRow1Size: "小",
        qualityRow1Use: "网页优化、缩略图",
        qualityRow2Size: "中",
        qualityRow2Use: "社交媒体发布、网页显示",
        qualityRow3Size: "大",
        qualityRow3Use: "高品质保存、打印",
        qualityRow4Size: "非常大",
        qualityRow4Use: "存档、专业用途",
        qualityNote: "※ 默认92%在品质和文件大小之间取得良好平衡"
      },
      de: {
        overview: "Übersicht",
        overviewText: "Dieses Tool ermöglicht es Ihnen, EXIF-Informationen (Kamera, Objektiv, Aufnahmeeinstellungen usw.) als Wasserzeichen zu Ihren Fotos hinzuzufügen und diese mit Rahmen zu exportieren.",
        overviewFeatures: "・EXIF-Informationen automatisch extrahieren und Wasserzeichen-Text generieren<br>・Anzeigestil mit Vorlagenauswahl ändern<br>・Rahmenfarbe und -breite frei anpassen<br>・Aus über 50 Schriftarten wählen",
        selectImage: "1. Bild auswählen",
        selectFile: "Datei auswählen",
        exifNote: "JPEG mit EXIF empfohlen. RAW wird im Browser nicht unterstützt.",
        selectTemplate: "2. Vorlagenauswahl",
        layout: "Layout",
        defaultTemplate: "Standard (Detailliert)",
        simpleTemplate: "Einfach (Zentriert)",
        templateNote: "※ Standard: Detaillierte Infos unten links anzeigen　※ Einfach: Kamera-/Objektivname groß unten mittig anzeigen",
        watermarkSettings: "3. Wasserzeichen-Einstellungen",
        textLabel: "Text (Kann automatisch generiert überschreiben. Zeilenumbrüche unterstützt)",
        position: "Position",
        posBottomLeft: "Unten Links",
        posBottomRight: "Unten Rechts",
        posTopLeft: "Oben Links",
        posTopRight: "Oben Rechts",
        posBottomCenter: "Unten Mitte",
        posTopCenter: "Oben Mitte",
        posCenterLeft: "Mitte Links",
        posCenterRight: "Mitte Rechts",
        textAlign: "Textausrichtung",
        alignLeft: "Links",
        alignCenter: "Zentriert",
        alignRight: "Rechts",
        scale: "Skalierung",
        fontLabel: "Schriftart",
        customFont: "Benutzerdefinierte Schriftart (Optional)",
        customFontPlaceholder: "z.B.: 'EB Garamond', serif",
        showBackground: "Wasserzeichen-Hintergrund anzeigen",
        placementBase: "Platzierungsbasis",
        placementPhoto: "Innerhalb des Fotos",
        placementCanvas: "Gesamte Leinwand (inkl. Rahmen)",
        textDirection: "Textrichtung",
        horizontal: "Horizontal",
        rotateCCW: "90° drehen (gegen Uhrzeigersinn)",
        rotateCW: "90° drehen (im Uhrzeigersinn)",
        frameSettings: "4. Rahmen-Einstellungen",
        addFrame: "Rahmen hinzufügen",
        frameColor: "Rahmenfarbe",
        white: "Weiß",
        black: "Schwarz",
        frameColorNote: "※ Bei Auswahl von Schwarz wird der Wasserzeichen-Text weiß",
        frameTop: "Obere Rahmenbreite",
        frameBottom: "Untere Rahmenbreite",
        frameLeft: "Linke Rahmenbreite",
        frameRight: "Rechte Rahmenbreite",
        output: "5. Ausgabe",
        exportImage: "Bild exportieren (JPG)",
        jpegQuality: "JPEG-Qualität (50%～100%)",
        currentQuality: "Aktuell: ",
        qualityGuideTitle: "Qualitätsunterschiede",
        qualityTableHeader1: "Qualität",
        qualityTableHeader2: "Dateigröße",
        qualityTableHeader3: "Verwendung",
        qualityRow1Size: "Klein",
        qualityRow1Use: "Web-Optimierung, Miniaturansichten",
        qualityRow2Size: "Mittel",
        qualityRow2Use: "Social-Media-Posts, Web-Anzeige",
        qualityRow3Size: "Groß",
        qualityRow3Use: "Hochwertige Speicherung, Druck",
        qualityRow4Size: "Sehr groß",
        qualityRow4Use: "Archiv, professionelle Nutzung",
        qualityNote: "※ Standard 92% bietet ein gutes Gleichgewicht zwischen Qualität und Dateigröße"
      },
      ko: {
        overview: "개요",
        overviewText: "이 도구는 사진에 EXIF 정보(카메라, 렌즈, 촬영 설정 등)를 워터마크로 추가하고 프레임을 추가하여 내보낼 수 있습니다.",
        overviewFeatures: "・EXIF 정보를 자동 추출하여 워터마크 텍스트 생성<br>・템플릿 선택으로 표시 스타일 변경<br>・프레임 색상과 너비를 자유롭게 조정<br>・50가지 이상의 글꼴 선택 가능",
        selectImage: "1. 이미지 선택",
        selectFile: "파일 선택",
        exifNote: "EXIF가 포함된 JPEG 권장. 브라우저에서 RAW는 지원되지 않습니다.",
        selectTemplate: "2. 템플릿 선택",
        layout: "레이아웃",
        defaultTemplate: "기본 (상세 표시)",
        simpleTemplate: "간단 (중앙 레이아웃)",
        templateNote: "※ 기본: 왼쪽 하단에 상세 정보 표시　※ 간단: 하단 중앙에 카메라/렌즈 이름을 크게 표시",
        watermarkSettings: "3. 워터마크 설정",
        textLabel: "텍스트 (자동 생성 덮어쓰기 가능. 줄바꿈 지원)",
        position: "위치",
        posBottomLeft: "왼쪽 하단",
        posBottomRight: "오른쪽 하단",
        posTopLeft: "왼쪽 상단",
        posTopRight: "오른쪽 상단",
        posBottomCenter: "중앙 하단",
        posTopCenter: "중앙 상단",
        posCenterLeft: "중앙 왼쪽",
        posCenterRight: "중앙 오른쪽",
        textAlign: "텍스트 정렬",
        alignLeft: "왼쪽 정렬",
        alignCenter: "중앙 정렬",
        alignRight: "오른쪽 정렬",
        scale: "배율",
        fontLabel: "글꼴",
        customFont: "사용자 지정 글꼴 (선택사항)",
        customFontPlaceholder: "예: 'EB Garamond', serif",
        showBackground: "워터마크 배경 표시",
        placementBase: "배치 기준",
        placementPhoto: "사진 내부",
        placementCanvas: "전체 캔버스 (프레임 포함)",
        textDirection: "텍스트 방향",
        horizontal: "가로",
        rotateCCW: "90° 회전 (반시계 방향)",
        rotateCW: "90° 회전 (시계 방향)",
        frameSettings: "4. 프레임 설정",
        addFrame: "프레임 추가",
        frameColor: "프레임 색상",
        white: "흰색",
        black: "검은색",
        frameColorNote: "※ 검은색을 선택하면 워터마크 텍스트가 흰색으로 변경됩니다",
        frameTop: "상단 프레임 너비",
        frameBottom: "하단 프레임 너비",
        frameLeft: "왼쪽 프레임 너비",
        frameRight: "오른쪽 프레임 너비",
        output: "5. 출력",
        exportImage: "이미지 내보내기 (JPG)",
        jpegQuality: "JPEG 품질 (50%～100%)",
        currentQuality: "현재: ",
        qualityGuideTitle: "품질별 차이",
        qualityTableHeader1: "품질",
        qualityTableHeader2: "파일 크기",
        qualityTableHeader3: "용도",
        qualityRow1Size: "작음",
        qualityRow1Use: "웹 최적화, 썸네일",
        qualityRow2Size: "중간",
        qualityRow2Use: "SNS 게시, 웹 표시",
        qualityRow3Size: "큼",
        qualityRow3Use: "고품질 저장, 인쇄",
        qualityRow4Size: "매우 큼",
        qualityRow4Use: "아카이브, 전문가용",
        qualityNote: "※ 기본값 92%는 품질과 파일 크기의 균형이 좋습니다"
      },
      hi: {
        overview: "अवलोकन",
        overviewText: "यह टूल आपको अपनी तस्वीरों में EXIF जानकारी (कैमरा, लेंस, शूटिंग सेटिंग्स आदि) को वॉटरमार्क के रूप में जोड़ने और फ्रेम के साथ निर्यात करने की अनुमति देता है।",
        overviewFeatures: "・वॉटरमार्क टेक्स्ट उत्पन्न करने के लिए स्वचालित रूप से EXIF जानकारी निकालें<br>・टेम्पलेट चयन के साथ प्रदर्शन शैली बदलें<br>・फ्रेम का रंग और चौड़ाई स्वतंत्र रूप से समायोजित करें<br>・50 से अधिक फोंट में से चुनें",
        selectImage: "1. छवि चुनें",
        selectFile: "फ़ाइल चुनें",
        exifNote: "EXIF के साथ JPEG अनुशंसित। ब्राउज़र में RAW समर्थित नहीं है।",
        selectTemplate: "2. टेम्पलेट चयन",
        layout: "लेआउट",
        defaultTemplate: "डिफ़ॉल्ट (विस्तृत)",
        simpleTemplate: "सरल (केंद्र लेआउट)",
        templateNote: "※ डिफ़ॉल्ट: नीचे बाईं ओर विस्तृत जानकारी प्रदर्शित करें　※ सरल: नीचे केंद्र में कैमरा/लेंस का नाम बड़ा प्रदर्शित करें",
        watermarkSettings: "3. वॉटरमार्क सेटिंग्स",
        textLabel: "टेक्स्ट (स्वतः उत्पन्न को ओवरराइड कर सकते हैं। लाइन ब्रेक समर्थित)",
        position: "स्थिति",
        posBottomLeft: "नीचे बाएं",
        posBottomRight: "नीचे दाएं",
        posTopLeft: "ऊपर बाएं",
        posTopRight: "ऊपर दाएं",
        posBottomCenter: "नीचे केंद्र",
        posTopCenter: "ऊपर केंद्र",
        posCenterLeft: "केंद्र बाएं",
        posCenterRight: "केंद्र दाएं",
        textAlign: "टेक्स्ट संरेखण",
        alignLeft: "बाएं",
        alignCenter: "केंद्र",
        alignRight: "दाएं",
        scale: "स्केल",
        fontLabel: "फ़ॉन्ट",
        customFont: "कस्टम फ़ॉन्ट (वैकल्पिक)",
        customFontPlaceholder: "उदा: 'EB Garamond', serif",
        showBackground: "वॉटरमार्क पृष्ठभूमि दिखाएं",
        placementBase: "प्लेसमेंट आधार",
        placementPhoto: "फोटो के अंदर",
        placementCanvas: "संपूर्ण कैनवास (फ्रेम सहित)",
        textDirection: "टेक्स्ट दिशा",
        horizontal: "क्षैतिज",
        rotateCCW: "90° घुमाएं (वामावर्त)",
        rotateCW: "90° घुमाएं (दक्षिणावर्त)",
        frameSettings: "4. फ्रेम सेटिंग्स",
        addFrame: "फ्रेम जोड़ें",
        frameColor: "फ्रेम रंग",
        white: "सफेद",
        black: "काला",
        frameColorNote: "※ काला चुनने पर वॉटरमार्क टेक्स्ट सफेद हो जाएगा",
        frameTop: "ऊपरी फ्रेम चौड़ाई",
        frameBottom: "निचला फ्रेम चौड़ाई",
        frameLeft: "बायां फ्रेम चौड़ाई",
        frameRight: "दायां फ्रेम चौड़ाई",
        output: "5. आउटपुट",
        exportImage: "छवि निर्यात करें (JPG)",
        jpegQuality: "JPEG गुणवत्ता (50%～100%)",
        currentQuality: "वर्तमान: ",
        qualityGuideTitle: "गुणवत्ता अंतर",
        qualityTableHeader1: "गुणवत्ता",
        qualityTableHeader2: "फ़ाइल आकार",
        qualityTableHeader3: "उपयोग",
        qualityRow1Size: "छोटा",
        qualityRow1Use: "वेब अनुकूलन, थंबनेल",
        qualityRow2Size: "मध्यम",
        qualityRow2Use: "सोशल मीडिया पोस्ट, वेब प्रदर्शन",
        qualityRow3Size: "बड़ा",
        qualityRow3Use: "उच्च गुणवत्ता भंडारण, मुद्रण",
        qualityRow4Size: "बहुत बड़ा",
        qualityRow4Use: "संग्रह, पेशेवर उपयोग",
        qualityNote: "※ डिफ़ॉल्ट 92% गुणवत्ता और फ़ाइल आकार के बीच अच्छा संतुलन प्रदान करता है"
      }
    };

    let currentLang = 'ja';

    // ====== 言語切り替え関数 ======
    function setLanguage(lang) {
      currentLang = lang;
      const t = translations[lang];
      
      // セクションタイトル
      const sections = document.querySelectorAll('.card h2');
      if (sections[0]) sections[0].textContent = t.overview;
      if (sections[1]) sections[1].textContent = t.selectImage;
      if (sections[2]) sections[2].textContent = t.selectTemplate;
      if (sections[3]) sections[3].textContent = t.watermarkSettings;
      if (sections[4]) sections[4].textContent = t.frameSettings;
      if (sections[5]) sections[5].textContent = t.output;
      
      // 概要テキスト
      const cards = document.querySelectorAll('.card');
      const overviewP = cards[0].querySelectorAll('p');
      if (overviewP[0]) overviewP[0].textContent = t.overviewText;
      if (overviewP[1]) overviewP[1].innerHTML = t.overviewFeatures;
      
      // 1. 画像を選ぶ - ファイル選択ボタン
      const fileSelectBtn = el('fileSelectBtn');
      if (fileSelectBtn) fileSelectBtn.textContent = t.selectFile;
      
      // 1. 画像を選ぶ - EXIF注釈
      const card1Muted = cards[1].querySelector('.muted:last-of-type');
      if (card1Muted) card1Muted.textContent = t.exifNote;
      
      // 2. テンプレート選択
      const card2Labels = cards[2].querySelectorAll('label');
      if (card2Labels[0]) {
        const layoutLabel = card2Labels[0].childNodes[0];
        if (layoutLabel) layoutLabel.textContent = t.layout + '\n          ';
      }
      const templateSelect = el('template');
      if (templateSelect) {
        templateSelect.options[0].textContent = t.defaultTemplate;
        templateSelect.options[1].textContent = t.simpleTemplate;
      }
      const card2Muted = cards[2].querySelector('.muted');
      if (card2Muted) card2Muted.textContent = t.templateNote;
      
      // 3. 透かし設定
      const card3 = cards[3];
      const textLabel = card3.querySelector('label');
      if (textLabel) textLabel.textContent = t.textLabel;
      
      // 位置と揃え
      const card3Row1Labels = card3.querySelectorAll('.row')[0].querySelectorAll('label');
      if (card3Row1Labels[0]) {
        card3Row1Labels[0].childNodes[0].textContent = t.position + '\n            ';
      }
      if (card3Row1Labels[1]) {
        card3Row1Labels[1].childNodes[0].textContent = t.textAlign + '\n            ';
      }
      
      // 位置オプション
      const posSelect = el('pos');
      if (posSelect) {
        posSelect.options[0].textContent = t.posBottomLeft;
        posSelect.options[1].textContent = t.posBottomRight;
        posSelect.options[2].textContent = t.posTopLeft;
        posSelect.options[3].textContent = t.posTopRight;
        posSelect.options[4].textContent = t.posBottomCenter;
        posSelect.options[5].textContent = t.posTopCenter;
        posSelect.options[6].textContent = t.posCenterLeft;
        posSelect.options[7].textContent = t.posCenterRight;
      }
      
      // テキスト揃えオプション
      const textAlignSelect = el('textAlign');
      if (textAlignSelect) {
        textAlignSelect.options[0].textContent = t.alignLeft;
        textAlignSelect.options[1].textContent = t.alignCenter;
        textAlignSelect.options[2].textContent = t.alignRight;
      }
      
      // スケール
      const card3Row2Labels = card3.querySelectorAll('.row')[1].querySelectorAll('label');
      if (card3Row2Labels[0]) {
        card3Row2Labels[0].childNodes[0].textContent = t.scale + '\n            ';
      }
      
      // フォント
      const card3Row3Labels = card3.querySelectorAll('.row')[2].querySelectorAll('label');
      if (card3Row3Labels[0]) {
        card3Row3Labels[0].childNodes[0].textContent = t.fontLabel + '\n            ';
      }
      if (card3Row3Labels[1]) {
        card3Row3Labels[1].childNodes[0].textContent = t.customFont + '\n            ';
      }
      
      // カスタムフォントプレースホルダー
      const fontCustom = el('fontCustom');
      if (fontCustom) fontCustom.placeholder = t.customFontPlaceholder;
      
      // 透かし背景チェックボックス
      const wmBgLabel = card3.querySelector('.inline-controls label');
      if (wmBgLabel) {
        const checkbox = wmBgLabel.querySelector('input');
        wmBgLabel.childNodes[1].textContent = ' ' + t.showBackground;
      }
      
      // 配置基準と文字方向
      const card3Row4Labels = card3.querySelectorAll('.row')[3].querySelectorAll('label');
      if (card3Row4Labels[0]) {
        card3Row4Labels[0].childNodes[0].textContent = t.placementBase + '\n            ';
      }
      if (card3Row4Labels[1]) {
        card3Row4Labels[1].childNodes[0].textContent = t.textDirection + '\n            ';
      }
      
      // 配置基準オプション
      const wmPlacement = el('wmPlacement');
      if (wmPlacement) {
        wmPlacement.options[0].textContent = t.placementPhoto;
        wmPlacement.options[1].textContent = t.placementCanvas;
      }
      
      // 文字方向オプション
      const wmOrientation = el('wmOrientation');
      if (wmOrientation) {
        wmOrientation.options[0].textContent = t.horizontal;
        wmOrientation.options[1].textContent = t.rotateCCW;
        wmOrientation.options[2].textContent = t.rotateCW;
      }
      
      // 4. フレーム設定
      const card4 = cards[4];
      const showFrameLabel = card4.querySelector('label');
      if (showFrameLabel) {
        showFrameLabel.childNodes[1].textContent = ' ' + t.addFrame;
      }
      
      // フレーム色
      const frameColorLabel = card4.querySelectorAll('label')[1];
      if (frameColorLabel) {
        frameColorLabel.childNodes[0].textContent = t.frameColor + '\n          ';
      }
      
      // フレーム色オプション
      const frameColorSelect = el('frameColor');
      if (frameColorSelect) {
        frameColorSelect.options[0].textContent = t.white;
        frameColorSelect.options[1].textContent = t.black;
      }
      
      // フレーム色注釈
      const frameColorNote = card4.querySelectorAll('.muted')[0];
      if (frameColorNote) frameColorNote.textContent = t.frameColorNote;
      
      // フレーム幅ラベル
      const card4Labels = card4.querySelectorAll('label');
      // フレーム色は1番目、上は2番目、下は3番目、左は4番目、右は5番目
      if (card4Labels[2]) {
        const textNode = card4Labels[2].childNodes[0];
        if (textNode && textNode.nodeType === 3) {
          textNode.nodeValue = t.frameTop + '\n            ';
        }
      }
      if (card4Labels[3]) {
        const textNode = card4Labels[3].childNodes[0];
        if (textNode && textNode.nodeType === 3) {
          textNode.nodeValue = t.frameBottom + '\n            ';
        }
      }
      if (card4Labels[4]) {
        const textNode = card4Labels[4].childNodes[0];
        if (textNode && textNode.nodeType === 3) {
          textNode.nodeValue = t.frameLeft + '\n            ';
        }
      }
      if (card4Labels[5]) {
        const textNode = card4Labels[5].childNodes[0];
        if (textNode && textNode.nodeType === 3) {
          textNode.nodeValue = t.frameRight + '\n            ';
        }
      }
      
      // 5. 出力
      const saveBtn = document.querySelector('.btn.primary');
      if (saveBtn) saveBtn.textContent = t.exportImage;
      
      // JPEG品質
      const card5 = cards[5];
      const qualityLabel = card5.querySelector('label');
      if (qualityLabel) {
        qualityLabel.childNodes[0].textContent = t.jpegQuality + '\n            ';
      }
      
      // 現在の品質表示
      const currentQualitySpan = card5.querySelector('.muted');
      if (currentQualitySpan) {
        const textNode = currentQualitySpan.childNodes[0];
        if (textNode) textNode.textContent = t.currentQuality;
      }
      
      // 品質ガイド表
      const qualityGuideTitle = el('qualityGuideTitle');
      if (qualityGuideTitle) qualityGuideTitle.innerHTML = '<strong>' + t.qualityGuideTitle + '</strong>';
      
      const qualityTableHeader1 = el('qualityTableHeader1');
      if (qualityTableHeader1) qualityTableHeader1.textContent = t.qualityTableHeader1;
      
      const qualityTableHeader2 = el('qualityTableHeader2');
      if (qualityTableHeader2) qualityTableHeader2.textContent = t.qualityTableHeader2;
      
      const qualityTableHeader3 = el('qualityTableHeader3');
      if (qualityTableHeader3) qualityTableHeader3.textContent = t.qualityTableHeader3;
      
      const qualityRow1Size = el('qualityRow1Size');
      if (qualityRow1Size) qualityRow1Size.textContent = t.qualityRow1Size;
      
      const qualityRow1Use = el('qualityRow1Use');
      if (qualityRow1Use) qualityRow1Use.textContent = t.qualityRow1Use;
      
      const qualityRow2Size = el('qualityRow2Size');
      if (qualityRow2Size) qualityRow2Size.textContent = t.qualityRow2Size;
      
      const qualityRow2Use = el('qualityRow2Use');
      if (qualityRow2Use) qualityRow2Use.textContent = t.qualityRow2Use;
      
      const qualityRow3Size = el('qualityRow3Size');
      if (qualityRow3Size) qualityRow3Size.textContent = t.qualityRow3Size;
      
      const qualityRow3Use = el('qualityRow3Use');
      if (qualityRow3Use) qualityRow3Use.textContent = t.qualityRow3Use;
      
      const qualityRow4Size = el('qualityRow4Size');
      if (qualityRow4Size) qualityRow4Size.textContent = t.qualityRow4Size;
      
      const qualityRow4Use = el('qualityRow4Use');
      if (qualityRow4Use) qualityRow4Use.textContent = t.qualityRow4Use;
      
      const qualityNote = el('qualityNote');
      if (qualityNote) qualityNote.textContent = t.qualityNote;
      
      // HTML lang属性を更新
      document.documentElement.lang = lang;
      
      // メタディスクリプションを言語に応じて更新
      const metaDesc = document.querySelector('meta[name="description"]');
      if (metaDesc) {
        metaDesc.content = t.overviewText.replace(/<br>/g, ' ');
      }
      
      // OGタイトルを更新
      const ogTitle = document.querySelector('meta[property="og:title"]');
      if (ogTitle) {
        const titles = {
          ja: 'ExiFrame - 写真にEXIF情報とフレームを追加',
          en: 'ExiFrame - Add EXIF Watermarks & Frames to Your Photos',
          zh: 'ExiFrame - 为照片添加EXIF水印和边框',
          de: 'ExiFrame - EXIF-Wasserzeichen und Rahmen zu Fotos hinzufügen',
          ko: 'ExiFrame - 사진에 EXIF 워터마크와 프레임 추가',
          hi: 'ExiFrame - तस्वीरों में EXIF वॉटरमार्क और फ्रेम जोड़ें'
        };
        ogTitle.content = titles[lang] || titles.en;
      }
      
      // OG説明を更新
      const ogDesc = document.querySelector('meta[property="og:description"]');
      if (ogDesc) {
        ogDesc.content = t.overviewText.replace(/<br>/g, ' ');
      }
      
      // Twitter説明を更新
      const twitterDesc = document.querySelector('meta[name="twitter:description"]');
      if (twitterDesc) {
        twitterDesc.content = t.overviewText.replace(/<br>/g, ' ');
      }
      
      // ページタイトルを更新
      const pageTitles = {
        ja: 'ExiFrame - 写真にEXIF情報とフレームを追加',
        en: 'ExiFrame - Add EXIF Watermarks & Frames to Your Photos',
        zh: 'ExiFrame - 为照片添加EXIF水印和边框',
        de: 'ExiFrame - EXIF-Wasserzeichen und Rahmen zu Fotos hinzufügen',
        ko: 'ExiFrame - 사진에 EXIF 워터마크와 프레임 추가',
        hi: 'ExiFrame - तस्वीरों में EXIF वॉटरमार्क और फ्रेम जोड़ें'
      };
      document.title = pageTitles[lang] || pageTitles.en;
      
      // ローカルストレージに保存
      localStorage.setItem('exiframe_lang', lang);
    }

    // ====== DOMユーティリティ ======
    const el = (id)=>document.getElementById(id);

    // ====== UI要素参照 ======
    const file = el('file');
    const img = el('img');
    const cv = el('cv');
    const ctx = cv.getContext('2d');
    const previewArea = document.querySelector('.preview');

    const template = el('template');
    const wmText = el('wmText');
    const pos = el('pos');
    const textAlign = el('textAlign');
    const scale = el('scale');

    const fontFamily = el('fontFamily');
    const fontCustom = el('fontCustom');

    const wmBg = el('wmBg');
    const wmPlacement = el('wmPlacement');
    const wmOrientation = el('wmOrientation');

    const saveBtn = el('save');
    const quality = el('quality');
    const qval = el('qval');

    const showFrame = el('showFrame');
    const frameColor = el('frameColor');
    const frameTopW = el('frameTopW');
    const frameRightW = el('frameRightW');
    const frameBottomW = el('frameBottomW');
    const frameLeftW = el('frameLeftW');
    const frameTopWInput = el('frameTopWInput');
    const frameRightWInput = el('frameRightWInput');
    const frameBottomWInput = el('frameBottomWInput');
    const frameLeftWInput = el('frameLeftWInput');

    let meta = null;

    if(qval && quality){ qval.textContent = quality.value; }

    // ====== 画像選択：EXIF抽出 + プレビュー ======
    file.addEventListener('change', async ()=>{
      const f = file.files?.[0];
      if(!f) return;
      
      // ファイル名を表示
      const fileNameSpan = el('fileName');
      if (fileNameSpan) fileNameSpan.textContent = f.name;
      
      const url = URL.createObjectURL(f);
      img.src = url;

      // EXIF を読む
      try{
        meta = await exifr.parse(f);
        wmText.value = formatExif(meta, template.value);
        setTimeout(()=>{ wmText.selectionStart = wmText.selectionEnd = wmText.value.length; }, 0);
      }catch(err){
        console.warn('EXIF 読み込み失敗', err);
        meta = {};
        wmText.value = '';
      }

      // 画像ロード後に描画（Webフォント待ち合わせ）
      img.onload = () => {
        const doDraw = () => {
          draw();
          URL.revokeObjectURL(url);
          saveBtn.disabled = false;
        };
        if (document.fonts && document.fonts.ready) {
          document.fonts.ready.then(doDraw);
        } else {
          doDraw();
        }
      };
    });

    // ====== メイン描画 ======
    function draw(){
      if(!img.complete) return;
      const w = img.naturalWidth, h = img.naturalHeight;

      // 画像サイズで初期化
      cv.width = w; cv.height = h;
      ctx.clearRect(0,0,cv.width,cv.height);
      ctx.drawImage(img, 0, 0, w, h);

      // 写真領域（デフォルトは画像全体）
      let contentX = 0, contentY = 0, contentW = w, contentH = h;

      // フレーム描画 + outside用 余白帯の矩形
      let bands = null; // {top|right|bottom|left: {x,y,w,h}}
      if (showFrame.checked) {
        // 各辺の幅を取得
        const fwTop = parseInt(frameTopW.value, 10);
        const fwRight = parseInt(frameRightW.value, 10);
        const fwBottom = parseInt(frameBottomW.value, 10);
        const fwLeft = parseInt(frameLeftW.value, 10);
        
        // フレーム色の設定
        const isBlackFrame = frameColor.value === 'black';
        const frameFill = isBlackFrame ? 'rgba(0,0,0,0.9)' : 'rgba(255,255,255,0.9)';
        const canvasBg = isBlackFrame ? '#ffffff' : '#ffffff'; // 外側は常に白

        // 外側：キャンバス拡張（常にこのモードのみ）
        const add = {
          top:    fwTop,
          right:  fwRight,
          bottom: fwBottom,
          left:   fwLeft,
        };
        const W = w + add.left + add.right;
        const H = h + add.top  + add.bottom;
        cv.width = W; cv.height = H;

        // Canvas全体を背景色で塗りつぶす
        ctx.fillStyle = canvasBg;
        ctx.fillRect(0, 0, W, H);

        contentX = add.left; contentY = add.top; contentW = w; contentH = h;

        ctx.drawImage(img, contentX, contentY, w, h);

        ctx.save();
        ctx.fillStyle = frameFill;

        // 各辺のフレームを個別の幅で描画（角が確実に塗りつぶされるように上下を先に描画）
        if (fwTop > 0)    ctx.fillRect(0, 0, W, fwTop);
        if (fwBottom > 0) ctx.fillRect(0, H - fwBottom, W, fwBottom);
        if (fwLeft > 0)   ctx.fillRect(0, fwTop, fwLeft, H - fwTop - fwBottom);
        if (fwRight > 0)  ctx.fillRect(W - fwRight, fwTop, fwRight, H - fwTop - fwBottom);
        ctx.restore();

        // フレーム帯を余白として保持
        bands = {
          top:    fwTop > 0    ? {x:0, y:0,                 w:cv.width,  h:fwTop}    : {x:0,y:0,w:0,h:0},
          bottom: fwBottom > 0 ? {x:0, y:cv.height-fwBottom, w:cv.width,  h:fwBottom} : {x:0,y:0,w:0,h:0},
          left:   fwLeft > 0   ? {x:0, y:0,                 w:fwLeft,    h:cv.height} : {x:0,y:0,w:0,h:0},
          right:  fwRight > 0  ? {x:cv.width-fwRight, y:0,  w:fwRight,   h:cv.height} : {x:0,y:0,w:0,h:0},
        };
      }

      // ▼ 透かしテキスト
      const text = wmText.value; // 改行保持
      if(text && text.trim().length > 0){
        // 文字サイズとフォント
        const base = Math.max(16, Math.min(contentW, contentH) * 0.022) * parseFloat(scale.value);
        const familyFromUI = (fontCustom?.value && fontCustom.value.trim()) || (fontFamily?.value) || "system-ui,-apple-system,Segoe UI,Roboto,Arial,Meiryo,'Hiragino Kaku Gothic ProN',sans-serif";
        ctx.font = Math.round(base) + 'px ' + familyFromUI;
        ctx.textBaseline = 'bottom';
        const op = 0.9; // 固定値
        const margin = 24; // 固定値

        // 配置基準（写真内側 / キャンバス全体）
        const placement = wmPlacement?.value || 'photo';

        let area;
        let isBottomFrameArea = false; // 下フレーム領域フラグ
        if (placement === 'photo') {
          area = {x: contentX, y: contentY, w: contentW, h: contentH};
        } else { // canvas
          // 中央下の場合は特別処理：写真最下部とフレーム最下部の中間領域に配置
          if (pos.value === 'bc' && showFrame.checked) {
            const fwBottom = parseInt(frameBottomW.value, 10);
            if (fwBottom > 0) {
              // 写真の下端からキャンバス最下部までの領域
              area = {
                x: 0, 
                y: contentY + contentH, 
                w: cv.width, 
                h: fwBottom
              };
              isBottomFrameArea = true;
            } else {
              area = {x: 0, y: 0, w: cv.width, h: cv.height};
            }
          } else {
            area = {x: 0, y: 0, w: cv.width, h: cv.height};
          }
        }

        // フレーム色と配置に応じて透かし文字色を決定
        const isBlackFrame = showFrame.checked && frameColor.value === 'black';
        const isWhiteFrame = showFrame.checked && frameColor.value === 'white';
        
        // 白フレーム時、配置がcanvasの場合はフレーム領域にあると判断して文字を黒に
        const isOnWhiteFrame = isWhiteFrame && placement === 'canvas';
        
        let textStrokeColor, textFillColor, bgColor;
        if (isBlackFrame) {
          // 黒フレーム時：白文字
          textStrokeColor = `rgba(0,0,0,${0.35*op})`;
          textFillColor = `rgba(255,255,255,${0.95*op})`;
          bgColor = `rgba(0,0,0,${0.35*op})`;
        } else if (isOnWhiteFrame) {
          // 白フレーム領域時：黒文字
          textStrokeColor = `rgba(255,255,255,${0.35*op})`;
          textFillColor = `rgba(0,0,0,${0.95*op})`;
          bgColor = `rgba(255,255,255,${0.35*op})`;
        } else {
          // デフォルト（写真上）：白文字
          textStrokeColor = `rgba(0,0,0,${0.35*op})`;
          textFillColor = `rgba(255,255,255,${0.95*op})`;
          bgColor = `rgba(0,0,0,${0.35*op})`;
        }

        // 文字方向
        const orientation = wmOrientation?.value || 'horizontal';

        if (orientation === 'horizontal') {
          // 横書き
          const maxWidth = Math.max(50, area.w - margin*2);
          const lines = wrapTextPreserveNewlines(ctx, text, maxWidth);
          const lh = base*1.4;
          const bh = lh*lines.length;
          const bw = Math.max(...lines.map(t=>ctx.measureText(t).width), 0);
          const p = calcPosRect(pos.value, area, bw, bh, margin);
          
          // テキスト揃えの設定
          const align = textAlign?.value || 'left';

          // 背景枠の描画
          if (wmBg?.checked) {
            ctx.save();
            ctx.fillStyle = bgColor;
            const bgPad = 24; // 固定値
            // 最初の行のy座標（下端）: p.y - bh + lh
            // 最後の行のy座標（下端）: p.y
            // 背景枠のy座標（上端）: p.y - bh
            roundRect(ctx, p.x - bgPad/2, p.y - bh - bgPad/2, bw + bgPad, bh + bgPad, 12);
            ctx.fill();
            ctx.restore();
          }
          lines.forEach((t,i)=>{
            const y = p.y - bh + (i+1)*lh; // i=0で最初の行、その下端はp.y - bh + lh
            
            // 各行の幅を計算してテキスト揃えを適用
            const lineWidth = ctx.measureText(t).width;
            let x = p.x;
            if (align === 'center') {
              x = p.x + (bw - lineWidth) / 2;
            } else if (align === 'right') {
              x = p.x + (bw - lineWidth);
            }
            
            ctx.strokeStyle = textStrokeColor;
            ctx.lineWidth = Math.ceil(base/8);
            if(t){ ctx.strokeText(t, x, y); }
            ctx.fillStyle = textFillColor;
            if(t){ ctx.fillText(t, x, y); }
          });

        } else {
          // 回転描画（横書きレイアウトを90°回転）
          const maxWidth = Math.max(50, area.w - margin*2);
          const lines = wrapTextPreserveNewlines(ctx, text, maxWidth);
          const lh = base*1.4;                      // 横書きと同じ行間
          const bh = lh * lines.length;             // 横書き時の高さ
          const bw = Math.max(...lines.map(t=>ctx.measureText(t).width), 0); // 横書き時の幅

          const bwRot = bh; // 幅 ← 高さ
          const bhRot = bw; // 高さ ← 幅
          const pTL = calcPosRectTL(pos.value, area, bwRot, bhRot, margin);
          
          // テキスト揃えの設定
          const align = textAlign?.value || 'left';

          // 背景枠の描画
          if (wmBg?.checked) {
            ctx.save();
            ctx.fillStyle = bgColor;
            const bgPad = 24; // 固定値
            roundRect(ctx, pTL.x - bgPad/2, pTL.y - bgPad/2, bwRot + bgPad, bhRot + bgPad, 12);
            ctx.fill();
            ctx.restore();
          }

          ctx.save();
          if (orientation === 'rotate-ccw') {
            ctx.translate(pTL.x, pTL.y + bhRot);
            ctx.rotate(-Math.PI / 2);
          } else { // rotate-cw
            ctx.translate(pTL.x + bwRot, pTL.y);
            ctx.rotate( Math.PI / 2);
          }
          ctx.textBaseline = 'top';
          lines.forEach((t,i)=>{
            const y = i * lh;
            
            // 各行の幅を計算してテキスト揃えを適用
            const lineWidth = ctx.measureText(t).width;
            let x = 0;
            if (align === 'center') {
              x = (bw - lineWidth) / 2;
            } else if (align === 'right') {
              x = (bw - lineWidth);
            }
            
            ctx.strokeStyle = textStrokeColor;
            ctx.lineWidth = Math.ceil(base/8);
            if(t){ ctx.strokeText(t, x, y); }
            ctx.fillStyle = textFillColor;
            if(t){ ctx.fillText(t, x, y); }
          });
          ctx.restore();
        }
      }
    }

    // ====== debounce関数（連続した呼び出しを制限）======
    function debounce(func, wait) {
      let timeout;
      return function executedFunction(...args) {
        const later = () => {
          clearTimeout(timeout);
          func(...args);
        };
        clearTimeout(timeout);
        timeout = setTimeout(later, wait);
      };
    }

    // 最適化された描画関数（デバウンス付き）
    const debouncedDraw = debounce(draw, 16); // 約60fps

    // ====== 入力変更で即再描画 ======
    // テキスト入力など：デバウンス付き（軽量化）
    [
      wmText,
      fontFamily,fontCustom
    ].forEach(e=> e && e.addEventListener('input', debouncedDraw));
    
    // フレームとUI要素：即座に反映（レスポンス重視）
    [
      pos,scale,textAlign,
      wmBg, wmPlacement, wmOrientation,
      showFrame,frameColor,frameTopW,frameRightW,frameBottomW,frameLeftW
    ].forEach(e=> e && e.addEventListener('input', draw));

    // フレーム幅：スライダーと数値入力の双方向同期
    if(frameTopW && frameTopWInput){
      frameTopW.addEventListener('input', ()=>{ 
        frameTopWInput.value = frameTopW.value; 
      });
      frameTopWInput.addEventListener('input', ()=>{ 
        const val = Math.max(0, Math.min(700, parseInt(frameTopWInput.value) || 0));
        frameTopWInput.value = val;
        frameTopW.value = val;
        draw();
      });
    }
    if(frameRightW && frameRightWInput){
      frameRightW.addEventListener('input', ()=>{ 
        frameRightWInput.value = frameRightW.value; 
      });
      frameRightWInput.addEventListener('input', ()=>{ 
        const val = Math.max(0, Math.min(700, parseInt(frameRightWInput.value) || 0));
        frameRightWInput.value = val;
        frameRightW.value = val;
        draw();
      });
    }
    if(frameBottomW && frameBottomWInput){
      frameBottomW.addEventListener('input', ()=>{ 
        frameBottomWInput.value = frameBottomW.value; 
      });
      frameBottomWInput.addEventListener('input', ()=>{ 
        const val = Math.max(0, Math.min(700, parseInt(frameBottomWInput.value) || 0));
        frameBottomWInput.value = val;
        frameBottomW.value = val;
        draw();
      });
    }
    if(frameLeftW && frameLeftWInput){
      frameLeftW.addEventListener('input', ()=>{ 
        frameLeftWInput.value = frameLeftW.value; 
      });
      frameLeftWInput.addEventListener('input', ()=>{ 
        const val = Math.max(0, Math.min(700, parseInt(frameLeftWInput.value) || 0));
        frameLeftWInput.value = val;
        frameLeftW.value = val;
        draw();
      });
    }

    // テンプレート変更時にEXIF情報を再生成＋位置を調整
    template.addEventListener('change', ()=>{
      if(meta){
        wmText.value = formatExif(meta, template.value);
      }
      // シンプルテンプレートの場合は中央下・中央揃えに配置
      if(template.value === 'simple'){
        pos.value = 'bc';
        textAlign.value = 'center';
      } else {
        pos.value = 'bl';
        textAlign.value = 'left';
      }
      draw();
    });

    // 品質スライダーのライブ表示
    if(quality){ quality.addEventListener('input', ()=>{ qval.textContent = quality.value; }); }

    // ====== 保存（JPG） ======
    saveBtn.addEventListener('click', ()=>{
      const q = Math.max(0, Math.min(1, parseFloat(quality?.value)||0.92));
      const a = document.createElement('a');
      a.href = cv.toDataURL('image/jpeg', q);
      a.download = `sukashi_${Date.now()}.jpg`;
      a.click();
    });

    // ====== EXIF → 透かし文字列 ======
    function formatExif(m, templateType){
      if(!m) return '';
      
      if(templateType === 'simple'){
        // シンプルテンプレート：中央下部レイアウト
        const make = m.Make || '';
        const model = m.Model || '';
        const camera = [make, model].filter(Boolean).join(' ') || 'Unknown Camera';
        
        const lens = (m.LensModel || m.Lens) || 'Unknown Lens';
        const focalLength = m.FocalLength ? `${Math.round(m.FocalLength)}mm` : '';
        const aperture = m.FNumber ? `F${Number(m.FNumber).toFixed(1)}` : '';
        const shutter = m.ExposureTime 
          ? (m.ExposureTime < 1 ? `1/${Math.round(1/m.ExposureTime)}s` : `${m.ExposureTime.toFixed(1)}s`)
          : '';
        const iso = m.ISO ? `ISO${m.ISO}` : '';
        
        // 1行目：カメラ名
        const line1 = camera;
        // 2行目：焦点距離 絞り レンズ名（スペース区切り）
        const line2 = [focalLength, aperture, lens].filter(Boolean).join(' ');
        // 3行目：パラメータ（ - 区切り、小さめ）
        const line3 = [focalLength, `f/${Number(m.FNumber || 0).toFixed(1)}`, shutter, iso].filter(Boolean).join(' - ');
        
        return `${line1}\n${line2}\n${line3}`;
      } else {
        // デフォルトテンプレート：詳細表示
        const cam = (m.Make || m.Model) ? `Camera: ${[m.Make, m.Model].filter(Boolean).join(' ')}` : 'Camera: unknown';
        const lens = (m.LensModel || m.Lens) ? `Lens: ${m.LensModel || m.Lens}` : 'Lens: unknown';
        const fnum = m.FNumber ? `Aperture: f/${Number(m.FNumber).toFixed(1)}` : 'Aperture: unknown';
        const ss = (m.ExposureTime)
          ? (m.ExposureTime < 1 ? `Shutter: 1/${Math.round(1/m.ExposureTime)}s` : `Shutter: ${m.ExposureTime.toFixed(1)}s`)
          : 'Shutter: unknown';
        const iso = m.ISO ? `ISO: ${m.ISO}` : 'ISO: unknown';
        const fl = m.FocalLength ? `Focal: ${Math.round(m.FocalLength)}mm` : 'Focal: unknown';
        const dt = m.DateTimeOriginal || m.CreateDate || m.ModifyDate
          ? `Date: ${m.DateTimeOriginal || m.CreateDate || m.ModifyDate}`
          : 'Date: unknown';
        return [cam, lens, fnum, ss, iso, fl].join('  |  ') + `\n${dt}`;
      }
    }

    // ====== 位置計算（baseline=bottom） ======
    function calcPosRect(position, area, bw, bh, margin){
      const map = {
        "bl": { x: area.x + margin,               y: area.y + area.h - margin },
        "br": { x: area.x + area.w - bw - margin, y: area.y + area.h - margin },
        "tl": { x: area.x + margin,               y: area.y + bh + margin },
        "tr": { x: area.x + area.w - bw - margin, y: area.y + bh + margin },
        "bc": { x: area.x + (area.w - bw)/2,      y: area.y + area.h - margin },
        "tc": { x: area.x + (area.w - bw)/2,      y: area.y + bh + margin },
        "cl": { x: area.x + margin,               y: area.y + (area.h + bh)/2 },
        "cr": { x: area.x + area.w - bw - margin, y: area.y + (area.h + bh)/2 },
      };
      return map[position] || map["bl"];
    }

    // ====== 位置計算（左上基準：回転後ボックス） ======
    function calcPosRectTL(position, area, bw, bh, margin){
      const map = {
        "bl": { x: area.x + margin,               y: area.y + area.h - bh - margin },
        "br": { x: area.x + area.w - bw - margin, y: area.y + area.h - bh - margin },
        "tl": { x: area.x + margin,               y: area.y + margin },
        "tr": { x: area.x + area.w - bw - margin, y: area.y + margin },
        "bc": { x: area.x + (area.w - bw)/2,      y: area.y + area.h - bh - margin },
        "tc": { x: area.x + (area.w - bw)/2,      y: area.y + margin },
        "cl": { x: area.x + margin,               y: area.y + (area.h - bh)/2 },
        "cr": { x: area.x + area.w - bw - margin, y: area.y + (area.h - bh)/2 },
      };
      return map[position] || map["bl"];
    }

    // ====== 角丸矩形 ======
    function roundRect(ctx, x, y, w, h, r){
      const radius = Math.min(r, w / 2, h / 2);
      ctx.beginPath();
      ctx.moveTo(x + radius, y);
      ctx.arcTo(x + w, y, x + w, y + h, radius);
      ctx.arcTo(x + w, y + h, x, y + h, radius);
      ctx.arcTo(x, y + h, x, y, radius);
      ctx.arcTo(x, y, x + w, y, radius);
      ctx.closePath();
    }

    // ====== テキスト折返し（改行保持） ======
    function wrapTextPreserveNewlines(ctx, text, maxWidth){
      const paras = text.split(/\r?\n/);
      const lines = [];
      for(const para of paras){
        if(para === ''){ lines.push(''); continue; }
        const words = para.split(/\s+/);
        let line = '';
        for(const w of words){
          const test = line ? (line + ' ' + w) : w;
          if(ctx.measureText(test).width > maxWidth && line){
            lines.push(line);
            line = w;
          }else{
            line = test;
          }
        }
        lines.push(line);
      }
      return lines;
    }

    // ====== 数値成形 ======
    const num = (v)=> typeof v==='number'? v.toFixed(5) : v;

    // ====== キャンバスの拡大縮小とドラッグ機能 ======
    let canvasScale = 1;
    let translateX = 0;
    let translateY = 0;
    let isDragging = false;
    let startX = 0;
    let startY = 0;

    // マウスホイールで拡大縮小（黒いエリア全体で有効）
    previewArea.addEventListener('wheel', (e) => {
      e.preventDefault();
      const delta = e.deltaY > 0 ? 0.9 : 1.1;
      canvasScale *= delta;
      canvasScale = Math.max(0.1, Math.min(5, canvasScale)); // 0.1倍〜5倍に制限
      updateCanvasTransform();
    }, { passive: false });

    // マウスドラッグで移動
    cv.addEventListener('mousedown', (e) => {
      isDragging = true;
      startX = e.clientX - translateX;
      startY = e.clientY - translateY;
    });

    cv.addEventListener('mousemove', (e) => {
      if (!isDragging) return;
      translateX = e.clientX - startX;
      translateY = e.clientY - startY;
      updateCanvasTransform();
    });

    cv.addEventListener('mouseup', () => {
      isDragging = false;
    });

    cv.addEventListener('mouseleave', () => {
      isDragging = false;
    });

    // タッチデバイス対応
    let lastTouchDistance = 0;
    cv.addEventListener('touchstart', (e) => {
      if (e.touches.length === 1) {
        isDragging = true;
        startX = e.touches[0].clientX - translateX;
        startY = e.touches[0].clientY - translateY;
      } else if (e.touches.length === 2) {
        const dx = e.touches[0].clientX - e.touches[1].clientX;
        const dy = e.touches[0].clientY - e.touches[1].clientY;
        lastTouchDistance = Math.sqrt(dx * dx + dy * dy);
      }
    });

    cv.addEventListener('touchmove', (e) => {
      e.preventDefault();
      if (e.touches.length === 1 && isDragging) {
        translateX = e.touches[0].clientX - startX;
        translateY = e.touches[0].clientY - startY;
        updateCanvasTransform();
      } else if (e.touches.length === 2) {
        const dx = e.touches[0].clientX - e.touches[1].clientX;
        const dy = e.touches[0].clientY - e.touches[1].clientY;
        const distance = Math.sqrt(dx * dx + dy * dy);
        if (lastTouchDistance > 0) {
          const delta = distance / lastTouchDistance;
          canvasScale *= delta;
          canvasScale = Math.max(0.1, Math.min(5, canvasScale));
          updateCanvasTransform();
        }
        lastTouchDistance = distance;
      }
    }, { passive: false });

    cv.addEventListener('touchend', () => {
      isDragging = false;
      lastTouchDistance = 0;
    });

    // ダブルクリックでリセット
    cv.addEventListener('dblclick', () => {
      canvasScale = 1;
      translateX = 0;
      translateY = 0;
      updateCanvasTransform();
    });

    function updateCanvasTransform() {
      cv.style.transform = `translate(${translateX}px, ${translateY}px) scale(${canvasScale})`;
    }

    // ====== 言語切り替えイベントリスナー ======
    const langSelect = el('langSelect');
    langSelect.addEventListener('change', (e) => {
      setLanguage(e.target.value);
    });

    // ====== 初期化：URLパラメータまたは保存された言語を読み込み ======
    const urlParams = new URLSearchParams(window.location.search);
    const urlLang = urlParams.get('lang');
    const supportedLangs = ['ja', 'en', 'zh', 'de', 'ko', 'hi'];
    const savedLang = localStorage.getItem('exiframe_lang') || 'ja';
    
    // URLパラメータがあり、サポートされている言語の場合はそれを使用
    const initialLang = (urlLang && supportedLangs.includes(urlLang)) ? urlLang : savedLang;
    
    langSelect.value = initialLang;
    setLanguage(initialLang);

    // ====== 初期：フォント読み込み後に空描画 ======
    if (document.fonts && document.fonts.ready) {
      document.fonts.ready.then(() => draw());
    }
  </script>
</body>
</html>
